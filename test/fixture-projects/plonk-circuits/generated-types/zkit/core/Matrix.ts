/* Autogenerated file. Do not edit manually. */
// @ts-nocheck
/* tslint:disable */
/* eslint-disable */

import {
  CircuitZKit,
  CircuitZKitConfig,
  Groth16Proof,
  PlonkProof,
  Groth16ProofPoints,
  PlonkProofPoints,
  NumberLike,
  NumericString,
  PublicSignals,
  Groth16Implementer,
  PlonkImplementer,
} from "@solarity/zkit";

import { normalizePublicSignals, denormalizePublicSignals } from "../helpers";

export type PrivateMatrixPlonk = {
  a: NumberLike[][];
  b: NumberLike[][];
  c: NumberLike;
};

export type PublicMatrixPlonk = {
  d: NumberLike[][];
  e: NumberLike[][];
  f: NumberLike;
  a: NumberLike[][];
};

export type ProofMatrixPlonk = {
  proof: PlonkProof;
  publicSignals: PublicMatrixPlonk;
};

export type CalldataMatrixPlonk = {
  proofPoints: PlonkProofPoints;
  publicSignals: [
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
  ];
};

export type QualifiedSignalNames =
  | "main.d[0][0]"
  | "main.d[0][1]"
  | "main.d[0][2]"
  | "main.d[1][0]"
  | "main.d[1][1]"
  | "main.d[1][2]"
  | "main.d[2][0]"
  | "main.d[2][1]"
  | "main.d[2][2]"
  | "main.e[0][0]"
  | "main.e[0][1]"
  | "main.e[0][2]"
  | "main.e[1][0]"
  | "main.e[1][1]"
  | "main.e[1][2]"
  | "main.e[2][0]"
  | "main.e[2][1]"
  | "main.e[2][2]"
  | "main.f"
  | "main.a[0][0]"
  | "main.a[0][1]"
  | "main.a[0][2]"
  | "main.a[1][0]"
  | "main.a[1][1]"
  | "main.a[1][2]"
  | "main.a[2][0]"
  | "main.a[2][1]"
  | "main.a[2][2]"
  | "main.b[0][0]"
  | "main.b[0][1]"
  | "main.b[1][0]"
  | "main.b[1][1]";

export class Matrix extends CircuitZKit<"plonk"> {
  constructor(config: CircuitZKitConfig) {
    super(config, new PlonkImplementer());
  }

  public async generateProof(
    inputs: PrivateMatrixPlonk,
    witnessOverrides?: Partial<Record<QualifiedSignalNames, bigint>>,
  ): Promise<ProofMatrixPlonk> {
    const proof = await super.generateProof(inputs as any, witnessOverrides);

    return {
      proof: proof.proof,
      publicSignals: this._normalizePublicSignals(proof.publicSignals),
    };
  }

  public async calculateWitness(
    inputs: PrivateMatrixPlonk,
    witnessOverrides?: Partial<Record<QualifiedSignalNames, bigint>>,
  ): Promise<bigint[]> {
    return super.calculateWitness(inputs as any, witnessOverrides);
  }

  public async verifyProof(proof: ProofMatrixPlonk): Promise<boolean> {
    return super.verifyProof({
      proof: proof.proof,
      publicSignals: this._denormalizePublicSignals(proof.publicSignals),
    });
  }

  public async generateCalldata(proof: ProofMatrixPlonk): Promise<CalldataMatrixPlonk> {
    return super.generateCalldata({
      proof: proof.proof,
      publicSignals: this._denormalizePublicSignals(proof.publicSignals),
    });
  }

  public getSignalNames(): string[] {
    return ["d", "e", "f", "a"];
  }

  public getSignalDimensions(name: string): number[] {
    switch (name) {
      case "d":
        return [3, 3];
      case "e":
        return [3, 3];
      case "f":
        return [];
      case "a":
        return [3, 3];
      default:
        throw new Error(`Unknown signal name: ${name}`);
    }
  }

  private _normalizePublicSignals(publicSignals: PublicSignals): PublicMatrixPlonk {
    return normalizePublicSignals(publicSignals, this.getSignalNames(), this.getSignalDimensions);
  }

  private _denormalizePublicSignals(publicSignals: PublicMatrixPlonk): PublicSignals {
    return denormalizePublicSignals(publicSignals, this.getSignalNames());
  }
}

export default Matrix;
